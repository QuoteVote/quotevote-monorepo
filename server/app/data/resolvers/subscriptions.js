import { get } from 'lodash';
import { PubSub, withFilter } from 'graphql-subscriptions';
import { GRAPHQL_PORT } from '../../server';
// eslint-disable-next-line import/extensions,import/no-unresolved
import subDef from '~/type_definition/subscription_definition';

const pubsub = new PubSub({
  host: 'localhost',
  port: GRAPHQL_PORT,
});
pubsub.ee.setMaxListeners(0); // Unlimited

const subscribeAndFilterBasedOnFilter = (subscription) => ({
  subscribe: withFilter(
    () => {
      const eventTrigger = `${subscription}Event`;
      return pubsub.asyncIterator(eventTrigger);
    },
    (payload, args, context) => {
      const argsKeys = Object.keys(args);

      // If nothing to filter on, just return the data now
      if (argsKeys.length <= 0) {
        return true;
      }
      // Otherwise loop through each key (i.e. userId, postId, etc)
      // eslint-disable-next-line no-restricted-syntax
      for (const key of argsKeys) {
        // These are the key values our args earlier said we should use to
        // check if the user can get this payload:
        const whatWeAreWatching = [].concat(args[key] || context[key] || []).filter((x) => x);
        // The payload's data might be an array so we need to account for this:
        const rows = [].concat(get(payload, subscription, []));
        // And check every row to see if they're all valid for this user to get:
        // eslint-disable-next-line no-restricted-syntax,no-unused-vars
        for (const [i, row] of rows.entries()) {
          // These are who this row of the payload says should get the data:
          const whoThisIsFor = [].concat(get(row, key, [])).filter((x) => x);

          // Comparing the two to see if the user should get this payload.
          // For example, if whatWeAreWatching=[42,877], and if the row gave
          // us whoThisIsFor=[877], then that check will pass.
          // But if whoThisIsFor=[1337], then that check will fail:
          const shouldUserGetThisPayload = whoThisIsFor.some((x) => whatWeAreWatching.includes(x.toString()));
          if (!shouldUserGetThisPayload) {
            return false;
          }
        }
      }

      // All checks passed
      return true;
    },
  ),
});

const a = 'type Subscription {';
const aI = subDef.indexOf(a) + a.length;
const bI = subDef.indexOf('}');

const autoGeneratedSubscriptions = subDef
  .substring(aI, bI) // Get "type Subscription {...}"
  .replace(/\r\n/g, '\r')
  .replace(/\n/g, '\r')
  .split(/\r/) // Split on newlines
  .map((x) => x.match(/^\s+([a-zA-Z]+)/))
  .filter((x) => x)
  .map((x) => [x[1]]) // Get subscription names
// eslint-disable-next-line max-len
  .reduce((o, i) => Object.assign(o, { [i]: subscribeAndFilterBasedOnFilter(i) }), {}); // Generate subscriptions

const Subscription = {
  ...autoGeneratedSubscriptions,
  presenceUpdated: {
    subscribe: withFilter(
      () => pubsub.asyncIterator('presenceUpdatedEvent'),
      (payload, args, context) => {
        const { user } = context;
        if (!user || !user._id) {
          return false;
        }
        const allowed = payload?.presenceUpdated?.allowedUserIds || [];
        const matchesUser = allowed.includes(user._id.toString());
        const matchesTarget = !args.userId
          || payload?.presenceUpdated?.userId?.toString() === args.userId.toString();
        return matchesUser && matchesTarget;
      },
    ),
  },
  messageAdded: {
    subscribe: withFilter(
      () => pubsub.asyncIterator('messageAddedEvent'),
      (payload, args, context) => {
        const { user } = context;
        if (!user || !user._id) {
          return false;
        }
        const allowed = payload?.messageAdded?.allowedUserIds || [];
        const matchesUser = allowed.includes(user._id.toString());
        const matchesConversation = !args.conversationId
          || payload?.messageAdded?.conversationId?.toString() === args.conversationId.toString();
        return matchesUser && matchesConversation;
      },
    ),
  },
  typingUpdated: {
    subscribe: withFilter(
      () => pubsub.asyncIterator('typingUpdatedEvent'),
      (payload, args, context) => {
        const { user } = context;
        if (!user || !user._id) {
          return false;
        }
        const allowed = payload?.typingUpdated?.allowedUserIds || [];
        const matchesUser = allowed.includes(user._id.toString());
        const matchesConversation = !args.conversationId
          || payload?.typingUpdated?.conversationId?.toString() === args.conversationId.toString();
        const notSelf = payload?.typingUpdated?.userId?.toString() !== user._id.toString();
        return matchesUser && matchesConversation && notSelf;
      },
    ),
  },
  receiptUpdated: {
    subscribe: withFilter(
      () => pubsub.asyncIterator('receiptUpdatedEvent'),
      (payload, args, context) => {
        const { user } = context;
        if (!user || !user._id) {
          return false;
        }
        const allowed = payload?.receiptUpdated?.allowedUserIds || [];
        const matchesUser = allowed.includes(user._id.toString());
        const matchesConversation = !args.conversationId
          || payload?.receiptUpdated?.conversationId?.toString() === args.conversationId.toString();
        return matchesUser && matchesConversation;
      },
    ),
  },
};

export { pubsub, Subscription };
